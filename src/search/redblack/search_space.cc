#include "search_space.h"

#include "operator.h"
#include "state.h"
#include "../globals.h"
#include "state_registry.h"

#include <set>



template<>
auto SearchSpace<redblack::RBState, redblack::RBOperator>::trace_rb_path(const redblack::RBState &state, const std::vector<FactPair> &additional_goal_facts) const -> std::pair<std::set<FactPair>, std::vector<std::tuple<StateID, std::vector<OperatorID>, OperatorID>>> {
	assert(dynamic_cast<redblack::RBStateRegistry *>(&state_registry));
	assert(dynamic_cast<redblack::RBStateRegistry *>(&state_registry) == &state.get_rb_state_registry());
	auto &rb_state_registry = *dynamic_cast<redblack::RBStateRegistry *>(&state_registry);
	const auto &operators = rb_state_registry.get_operators();
	auto current_state = state;
	std::vector<std::vector<std::vector<OperatorID>>> best_supporters;
	auto path = std::vector<std::tuple<StateID, std::vector<OperatorID>, OperatorID>>();
    
    for (;;) {          // backtrace solution path
        const SearchNodeInfo &info = search_node_infos[current_state];
		if (current_state.get_id() == rb_state_registry.get_initial_state().get_id()) { // reached initial state ==> done
			best_supporters.push_back(rb_state_registry.get_initial_state_best_supporters());
			break;
		} else if (info.parent_state_id == StateID::no_state) { // reached state which was generated by a split from a different painting ==> done
			// such a state does not have any best supporters (it can't have any red facts that the parent doesn't)
			auto empty_best_supporters = std::vector<std::vector<OperatorID>>();
			empty_best_supporters.resize(g_root_task()->get_num_variables());
			for (auto var = 0; var < g_root_task()->get_num_variables(); ++var)
				empty_best_supporters[var].assign(g_root_task()->get_variable_domain_size(var), OperatorID(-1));
			best_supporters.emplace_back(std::move(empty_best_supporters));
			break;
		}

        const redblack::RBOperator *op = &operators[info.creating_operator];
        assert(op->is_black());

		path.emplace_back(info.parent_state_id, std::vector<OperatorID>(), op->get_id());
        current_state = state_registry.lookup_state(info.parent_state_id);

        best_supporters.push_back(rb_state_registry.get_best_supporters_for_successor(current_state, *op));
        // TODO to not waste so much memory, could do the whole relaxed plan reconstruction here
    }
    std::reverse(path.begin(), path.end());
    std::reverse(best_supporters.begin(), best_supporters.end());
	path.emplace_back(state.get_id(), std::vector<OperatorID>(), OperatorID(-1));

    std::set<FactPair> marked_facts;
	auto achieved_facts = std::make_unique<std::vector<std::set<FactPair>>>();
	for (const auto &goal_fact : additional_goal_facts) {
		if (state.get_painting().is_red_var(goal_fact.var)) {
			marked_facts.emplace(goal_fact);
#ifdef DEBUG_PLAN_EXTRACTION
			cout << "marked goal fact " << g_fact_names[goal.first][goal.second] << endl;
#endif
		}
	}
    //std::vector<const redblack::RBOperator *> plan;

    for (int step = best_supporters.size() - 1; step >= 0; --step){
#ifdef DEBUG_PLAN_EXTRACTION
        cout << "step " << step << endl;
#endif
        std::vector<OperatorID> ops_current_step;
        std::set<FactPair> remaining_marked;
		std::set<FactPair> new_marked;
		std::set<FactPair> achieved;
            
        bool change = true;
        while (change){
            change = false;
                
            new_marked.clear();
            for (auto const &fact : marked_facts){
#ifdef DEBUG_PLAN_EXTRACTION
                cout << "handling fact " << g_fact_names[fact.first][fact.second];
#endif
                auto op_id = best_supporters[step][fact.var][fact.value];
                if (op_id.get_index() == -1){
#ifdef DEBUG_PLAN_EXTRACTION                        
                    cout << " => cannot be achieved in this step" << endl;
#endif
                    remaining_marked.insert(fact);
                    continue;
                } else {
	                achieved.insert(fact);
                }
				const auto &op = operators[op_id.get_index()];
#ifdef DEBUG_PLAN_EXTRACTION
                cout << endl << "best supporter: " << op->get_name() << endl;;
#endif
                    
				// TODO: can't we simplify this? the best supporter may achieve multiple facts at once, we can probably save some operators
                if (std::find(ops_current_step.begin(), ops_current_step.end(), op_id) == ops_current_step.end()){
                    ops_current_step.push_back(op_id);
                    for (auto const &pre : op.get_red_preconditions()) {
						// TODO: ??
                        change |= new_marked.emplace(pre->var, pre->val).second;
#ifdef DEBUG_PLAN_EXTRACTION
                        cout << "marked precondition fact " << g_fact_names[pre->var][pre->val] << endl;
#endif
                    }
                }
            }
            marked_facts.swap(new_marked);
        }
        marked_facts.insert(remaining_marked.begin(), remaining_marked.end());
            
            
        // sequence the red operators so that they form a valid relaxed plan
	    std::vector<std::vector<bool> > current_red_state(g_variable_domain.size());
        for (size_t var = 0; var < g_variable_domain.size(); ++var){
            if (state.get_painting().is_red_var(var)){
                current_red_state[var].resize(g_variable_domain[var], false);
            }
        }

	    std::vector<OperatorID> sorted_ops;
	    std::vector<bool> handled_ops(ops_current_step.size(), false);
        while (sorted_ops.size() < ops_current_step.size()){
            for (size_t i = 0; i < ops_current_step.size(); ++i){
                if (handled_ops[i]){
                    continue;
                }
                const redblack::RBOperator *op = &operators[ops_current_step[i].get_index()];
#ifdef DEBUG_PLAN_EXTRACTION                        
                cout << "handling op " << op->get_name();
#endif                
                bool is_applicable = true;
                for (auto const &pre : op->get_red_preconditions()){
                    if (!current_red_state[pre->var][pre->val] && best_supporters[step][pre->var][pre->val].get_index() != -1){
                        is_applicable = false;
#ifdef DEBUG_PLAN_EXTRACTION                        
                        cout << " not applicable => keep for later";
#endif
                        break;
                    }
                }
                if (is_applicable){
                    handled_ops[i] = true;
                    sorted_ops.push_back(ops_current_step[i]);
                    for (auto const &eff : op->get_red_effects()){
                        current_red_state[eff->var][eff->val] = true;
                    }
                }
            }
        }

		std::reverse(std::begin(sorted_ops), std::end(sorted_ops));
		std::get<std::vector<OperatorID>>(path[step]) = std::move(sorted_ops);
            
        //plan.insert(plan.end(), sorted_ops.rbegin(), sorted_ops.rend());
		achieved_facts->emplace_back(std::move(achieved));
        if (step != 0){
            const redblack::RBOperator *black_op = &operators[std::get<OperatorID>(path[step - 1]).get_index()];
#ifdef DEBUG_PLAN_EXTRACTION
            cout << "appended black action " << black_op->get_name() << endl;
#endif
            //plan.push_back(black_op);
            for (auto const &pre : black_op->get_red_preconditions()){
                marked_facts.emplace(pre->var, pre->val);
            }
            for (auto const &eff : black_op->get_red_effects()){
                marked_facts.erase(FactPair(eff->var, eff->val));
            }
        }
    }
        
    //path = plan;
        
    //reverse(path.begin(), path.end());
	reverse(std::begin(*achieved_facts), std::end(*achieved_facts));
	rb_state_registry.set_last_marked_facts(std::move(achieved_facts));
        
#ifdef DEBUG_PLAN_EXTRACTION
    cout << endl;
    for (auto const &op : path){
        cout << op->get_name() << endl;
    }
    cout << endl;
#endif

	return {marked_facts, path};
}


template<>
void SearchSpace<redblack::RBState, redblack::RBOperator>::trace_path(const redblack::RBState &goal_state, std::vector<const redblack::RBOperator*> &path) const {
	assert(dynamic_cast<redblack::RBStateRegistry *>(&state_registry));
	assert(dynamic_cast<redblack::RBStateRegistry *>(&state_registry) == &goal_state.get_rb_state_registry());
	auto &rb_state_registry = *dynamic_cast<redblack::RBStateRegistry *>(&state_registry);
	const auto &operators = rb_state_registry.get_operators();
	auto current_state = goal_state;
	std::vector<std::vector<std::vector<OperatorID>>> best_supporters;
    assert(path.empty());
    
    for (;;) {          // backtrace solution path
        const SearchNodeInfo &info = search_node_infos[current_state];

        if (info.parent_state_id == StateID::no_state) {  // reached initial state => done
            best_supporters.push_back(rb_state_registry.get_initial_state_best_supporters());
            break;
        }
        const redblack::RBOperator *op = &operators[info.creating_operator];
        assert(op->is_black());

        path.push_back(op);
        current_state = state_registry.lookup_state(info.parent_state_id);

        best_supporters.push_back(rb_state_registry.get_best_supporters_for_successor(current_state, *op));
        // TODO to not waste so much memory, could do the whole relaxed plan reconstruction here
    }
    std::reverse(path.begin(), path.end());
    std::reverse(best_supporters.begin(), best_supporters.end());

    std::set<FactPair> marked_facts;
	auto achieved_facts = std::make_unique<std::vector<std::set<FactPair>>>();
    for (auto const &goal : g_goal){
        if (goal_state.get_painting().is_red_var(goal.first)){
            marked_facts.emplace(goal.first, goal.second);
#ifdef DEBUG_PLAN_EXTRACTION
            cout << "marked goal fact " << g_fact_names[goal.first][goal.second] << endl;
#endif
        }
    }
    std::vector<const redblack::RBOperator *> plan;

    for (int step = best_supporters.size() - 1; step >= 0; --step){
#ifdef DEBUG_PLAN_EXTRACTION
        cout << "step " << step << endl;
#endif
        std::vector<OperatorID> ops_current_step;
        std::set<FactPair> remaining_marked;
		std::set<FactPair> new_marked;
		std::set<FactPair> achieved;
            
        bool change = true;
        while (change){
            change = false;
                
            new_marked.clear();
            for (auto const &fact : marked_facts){
#ifdef DEBUG_PLAN_EXTRACTION
                cout << "handling fact " << g_fact_names[fact.first][fact.second];
#endif
                auto op_id = best_supporters[step][fact.var][fact.value];
                if (op_id.get_index() == -1){
#ifdef DEBUG_PLAN_EXTRACTION                        
                    cout << " => cannot be achieved in this step" << endl;
#endif
                    remaining_marked.insert(fact);
                    continue;
                } else {
	                achieved.insert(fact);
                }
				const auto &op = operators[op_id.get_index()];
#ifdef DEBUG_PLAN_EXTRACTION
                cout << endl << "best supporter: " << op->get_name() << endl;;
#endif
                    
				// TODO: can't we simplify this? the best supporter may achieve multiple facts at once, we can probably save some operators
                if (std::find(ops_current_step.begin(), ops_current_step.end(), op_id) == ops_current_step.end()){
                    ops_current_step.push_back(op_id);
                    for (auto const &pre : op.get_red_preconditions()) {
						// TODO: ??
                        change |= new_marked.emplace(pre->var, pre->val).second;
#ifdef DEBUG_PLAN_EXTRACTION
                        cout << "marked precondition fact " << g_fact_names[pre->var][pre->val] << endl;
#endif
                    }
                }
            }
            marked_facts.swap(new_marked);
        }
        marked_facts.insert(remaining_marked.begin(), remaining_marked.end());
            
            
        // sequence the red operators so that they form a valid relaxed plan
	    std::vector<std::vector<bool> > current_red_state(g_variable_domain.size());
        for (size_t var = 0; var < g_variable_domain.size(); ++var){
            if (goal_state.get_painting().is_red_var(var)){
                current_red_state[var].resize(g_variable_domain[var], false);
            }
        }

	    std::vector<const redblack::RBOperator *> sorted_ops;
	    std::vector<bool> handled_ops(ops_current_step.size(), false);
        while (sorted_ops.size() < ops_current_step.size()){
            for (size_t i = 0; i < ops_current_step.size(); ++i){
                if (handled_ops[i]){
                    continue;
                }
                const redblack::RBOperator *op = &operators[ops_current_step[i].get_index()];
#ifdef DEBUG_PLAN_EXTRACTION                        
                cout << "handling op " << op->get_name();
#endif                
                bool is_applicable = true;
                for (auto const &pre : op->get_red_preconditions()){
                    if (!current_red_state[pre->var][pre->val] && best_supporters[step][pre->var][pre->val].get_index() != -1){
                        is_applicable = false;
#ifdef DEBUG_PLAN_EXTRACTION                        
                        cout << " not applicable => keep for later";
#endif
                        break;
                    }
                }
                if (is_applicable){
                    handled_ops[i] = true;
                    sorted_ops.push_back(op);
                    for (auto const &eff : op->get_red_effects()){
                        current_red_state[eff->var][eff->val] = true;
                    }
                }
            }
        }
            
        plan.insert(plan.end(), sorted_ops.rbegin(), sorted_ops.rend());
		achieved_facts->emplace_back(std::move(achieved));
        if (step != 0){
            const redblack::RBOperator *black_op = path[step - 1];
#ifdef DEBUG_PLAN_EXTRACTION
            cout << "appended black action " << black_op->get_name() << endl;
#endif
            plan.push_back(black_op);
            for (auto const &pre : black_op->get_red_preconditions()){
                marked_facts.emplace(pre->var, pre->val);
            }
            for (auto const &eff : black_op->get_red_effects()){
                marked_facts.erase(FactPair(eff->var, eff->val));
            }
        }
    }
        
    path = plan;
        
    reverse(path.begin(), path.end());
	reverse(std::begin(*achieved_facts), std::end(*achieved_facts));
	rb_state_registry.set_last_marked_facts(std::move(achieved_facts));
        
#ifdef DEBUG_PLAN_EXTRACTION
    cout << endl;
    for (auto const &op : path){
        cout << op->get_name() << endl;
    }
    cout << endl;
#endif
        
#ifndef NDEBUG
    size_t number_red = 0;
    for (size_t var = 0; var < g_variable_domain.size(); ++var){
        if (goal_state.get_painting().is_red_var(var)){
            ++number_red;
        }
    }
    // only init state fact must be marked in the end
    // this is kind of a weak condition, it still allows multiple marked
    // facts for a single red variable in case there are others that are
    // not used at all
    assert(marked_facts.size() <= number_red);
#endif        
    //assert(is_redblack_plan(path));
        
    //if (g_painting->is_incremental_search() && is_real_plan(path)){
    //    g_rb_plan_is_real_plan = true;
    //}
}
